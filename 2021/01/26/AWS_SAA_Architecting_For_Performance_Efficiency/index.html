<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="X-UA-Compatible" content="IE=edge">
  <title>AWS SAA - Architecting for Performance Efficiency</title>
  <meta name="description" content="System Design - hellcy">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="short icon" href="/sitelogo.jpg">
  <link rel="stylesheet" href="/css/apollo.css">
</head>
<body>
  <header>
    <a href="/" class="logo-link"><img src="/sitelogo.jpg"></a>
    <ul class="nav nav-list">
      <li class="nav-list-item">
        <a href="/" target="_self" class="nav-list-link">Blog</a>
      </li>
      <li class="nav-list-item">
        <a href="https://github.com/hellcy" target="_blank" class="nav-list-link">Github</a>
      </li>
    </ul>
  </header>
  <section class="container">
    <div class="post">
      <article class="post-block">
        <h1 class="post-title">AWS SAA - Architecting for Performance Efficiency</h1>
        <div class="post-time">Jan 26, 2021</div>
        <div class="post-content">
          <ol id="title">
            <li><a href="#Part1">Part One: Understanding the Design Principles</a></li>
            <li><a href="#Part2">Part Two: Considering Compute Performance Options</a></li>
            <li><a href="#Part3">Part Three: Reviewing Storage Performance Options</a></li>
            <li><a href="#Part4">Part Four: Examing Database Performance Options</a></li>
            <li><a href="#Part5">Part Five: Evaluating Network Performance Options</a></li>
            <li><a href="#Part6">Part Six: Preparing to Improve Your Architecture</a></li>
            <li><a href="#Part7">Part Seven: Monitoring Your Architecture</a></li>
            <li><a href="#Part8">Part Eight: Understanding the Trade-offs</a></li>
          </ol>
          <h2 id="Part1">
            <a href="#title" class="headerlink" title="Part 1">Part One: Understanding the Design Principles</a>
          </h2>
          <p>There are three main differences compare traditional on premises application and cloud application. 1. Cost. 2. Security and 3. Performance. We are going to focus on number three. Performance.</p>
          <p>Cloud services are changing fast.</p>
          <p>Go global: AWS have many regions, deploy application to the region that close to the user to reduce the latancy.</p>
          <p>Go global: local region will comply to the laws and regulations</p>
          <ol>
            <li>Go global</li>
            <li>Think serverless</li>
            <li>Use new technologies</li>
            <li>Experiment often</li>
            <li>Right tool for the task</li>
          </ol>
          <h2 id="Part2">
            <a href="#title" class="headerlink" title="Part 2">Part Two: Considering Compute Performance Options</a>
          </h2>
          <p>What does compute performance includes?</p>
          <p>Processing -> CPU</p>
          <p>Capacity -> Storage</p>
          <p>Scaling</p>
          <p>Responsive</p>
          <p>Economical</p>
          <p>Understand your workload</p>
          <p>Undetstand AWS compute</p>
          <p>Need to gather and analyze data, and testing</p>
          <h3>AWS compute options</h3>
          <h4>EC2 Elastic Cloud Compute</h4>
          <p>The default option, virtualized servers. IssA (infrustructure as a service)</p>
          <p>Choose resources. You own the OS.(You are responsible for patching the OS and config all aspects of it.)</p>
          <p>EC2 General resources</p>
          <ol>
            <li>vCPUs</li>
            <li>Memory</li>
            <li>Storage</li>
            <li>Network</li>
          </ol>
          <p>EC2 extra features</p>
          <ol>
            <li>Burstable: if your EC2 is not using its full compute power, you gain credits which you can use in the future when you need it to burst the compute power of your instance for a short period of time.</li>
            <li>GPU</li>
            <li>FPGA (Filled Programmable Gate Arrays): Allows you to create customized hardware accelerators</li>
          </ol>
          <p>Instance Types</p>
          <ol>
            <li>General Purpose: Standard, balanced</li>
            <li>Compute optimized: high compute power</li>
            <li>Memory optimized: for memory intensive workloads</li>
            <li>Accelerated computing: GPU or FPGA</li>
            <li>Storage optimized: high storage</li>
            <li>Bare metal</li>
          </ol>
          <p>EC2 Auto Scaling</p>
          <ol>
            <li>Metrics based: scale up or down based on the metric you choose</li>
            <li>Schedule based: scale up or down for a booked time</li>
            <li>Health based: replace unhealthy instances</li>
          </ol>
          <h4>ECS Elastic Container Service</h4>
          <p>Similar workloads as EC2</p>
          <p>Migrate apps to the cloud, long running apps, batch processing, Microservices</p>
          <p>Better utilize resources. Can run multiple containers on a single instance. ELB, balance traffic to each container, Autoscaling.</p>
          <p>AWS Fargate: manages the instances on which your containers run. you don't need to manage the server instances.</p>
          <h4>AWS Lambda</h4>
          <p>FaaS (Function as a service). Serverless computing.</p>
          <p>Backend processing, Event processing, Stream processing, Data processing</p>
          <p>AWS resource triggers: other resources can trigger Lambda functions</p>
          <p>You can choose memory needed for a lambda function</p>
          <p>Advantages: Simply execute code. We don't need to worry about the servers that run our Lambda codes.</p>
          <p>Automatic scaling for Lambda function.</p>
          <p>Fault tolerant: if a function fails, AWS will trigger the function again</p>
          <p>Pay for usage</p>
          <h4>Applying our knowledge</h4>
          <p>1. A company called Globomantics wants to move their application to cloud. They have customers globally.</p>
          <p>The first application they want to move to cloud is an app that collections data from clinical trails. Doctors enter information each time they do checkings.</p>
          <p>Considerations for Choice</p>
          <ol>
            <li>First app of many</li>
            <li>Time should be fast</li>
            <li>Predicatable usage</li>
          </ol>
          <p>They want to use ECS. Lift and shift: Easy to containerize the app. Able to scale. Able to choose instance sizes.</p>
          <p>Allows them to leverage for future applications. Different containers in a single instance. Save costs</p>
          <p>2. They also want to build a new web application for the cloud. Allow people to register medical devices. Share medical devices globally.</p>
          <p>Considerations for Choice</p>
          <ol>
            <li>Manage costs</li>
            <li>Global reach</li>
            <li>Minimal maintenance</li>
          </ol>
          <p>They want to go with Lambda. Services behind a static site to save costs. Only pay for runtime.</p>
          <p>Lambda scales besed on demand. Can be deployed to multiple regions. No servers to maintain.</p>
          <h2 id="Part3">
            <a href="#title" class="headerlink" title="Part 3">Part Three: Reviewing Storage Performance Options</a>
          </h2>
          <h3>S3</h3>
          <p>data is encrypted. Access Managemenet(IAM), Lifecycle management. Query in place.(Don't need to move the data to query it using SQL like command)</p>
          <ol>
            <li>Shared Access</li>
            <li>Low latency</li>
            <li>High thoughput: move data in or out S3 quickly</li>
            <li>High Availability: available for multiple availability zones</li>
            <li>High durability: data is duplicated across multiple availability zones</li>
          </ol>
          <ol>
            <li>Standard</li>
            <li>Intelligent Tier</li>
            <li>Standard Infrequent Access(IA)(high latency)</li>
            <li>One-Zone Infrequent Access(low availability, low durability)</li>
          </ol>
          <h3>Glacier</h3>
          <p>Immutable, data do not change once they are in Glacier.</p>
          <p>Durable</p>
          <p>Query stored data without retrieval.</p>
          <ol>
            <li>Archival storage</li>
            <li>Encrypted</li>
            <li>Access Control</li>
            <li>Audit logging</li>
          </ol>
          <p>Latency options.</p>
          <ol>
            <li>Expedited. latency in minutes.</li>
            <li>Standard. Default, number of hours to get data back.</li>
            <li>Bulk. cheaper and takes longer.</li>
          </ol>
          <p>Economical, put data in Glacier is cheap and high durable.</p>
          <p>Deep Archive. The cheapest and longest. normally 6-12 hours. Do not access data frequently, 2-3 times a year.</p>
          <h3>EBS (Elastic Block Storage)</h3>
          <p>Attached to EC2 instances.</p>
          <p>Multi-Attach, storage volumn can be attached to up to 16 instances. Instances must be in same availability zone.</p>
          <p>Data is Replicated to multiple availbility zones. high availability and durability</p>
          <p>Access control.</p>
          <ol>
            <li>Provisioned IOPS SSD</li>
            <li>Standard Purpose IOPS SSD</li>
            <li>Cold HDD</li>
            <li>Thoughput optimized HDD</li>
          </ol>
          <p>Snapshots: a snapshots of a storage in that time and can be shared to other zones.</p>
          <p>Elastic volumes. pay for what actually stored.</p>
          <h3>EFS</h3>
          <p></p>
          <ol>
            <li>General Purpose</li>
            <li>MAX I/O</li>
          </ol>
          <p>Same example as before. Migrating to AWS storage. It is one of the web applications. It requires global access. Data will be collected from clinical trials. And some data will be entered on daliy basis.</p>
          <p>They need shared access of data.</p>
          <p>Data must be durable.</p>
          <p>Data will be stored in a long term basis.</p>
          <p>S3 and Glacier: high durable. Access from ECS containers. Multiple access. Long term storage.</p>
          <p>New application. Provide medical devices to people who need it. Global user base.</p>
          <p>Lower cost. Local access. Non-critical images(could be lost, no big problem).</p>
          <p>S3: single region. Reduced Redundancy Storage(RRD).</p>
          <h2 id="Part4">
            <a href="#title" class="headerlink" title="Part 4">Part Four: Examing Database Performance Options</a>
          </h2>
          <h3>Install on EC2</h3>
          <p>we could choose to install a Database on a EC2 instance. But that means we need to do all the backup, restore ourselves. We are not using the serverless managed services provided by AWS. But in some cases, we have to choose this way. Situations like: 1. Control Environment. we want to control everything. 2. Certified. Maybe the services in AWS are not certified by the customer. 3. Specific tools. Our application needs some tools that have to work with standalone database.</p>
          <ol>
            <li>RDS</li>
            <li>DynamoDB</li>
            <li>Redshift</li>
          </ol>
          <h3>RDS</h3>
          <p>Default choice. Complex queries. Consistent transactions.</p>
          <ol>
            <li>Multi-AZ</li>
            <li>Read replicas</li>
            <li>Encryption</li>
            <li>Backups and snapshots</li>
          </ol>
          <ol>
            <li>Instance type</li>
            <li>Storage type</li>
            <li>Network setup</li>
            <li>Backup</li>
          </ol>
          <h3>DynamoDB</h3>
          <p>Flexible structure</p>
          <ol>
            <li>Flexible structure</li>
            <li>Less complex queries: You are able to query on particular keys, the partition key and any secondary keys that you define. Can't join tables.</li>
            <li>Low latency</li>
            <li>Transactions</li>
            <li>Global tables: store data in multiple regions</li>
            <li>Encryption</li>
            <li>Evolving schema: supports changes and growth in your application(add/remove columns...)</li>
            <li>Integration with Lambda</li>
          </ol>
          <p>Partition key: store data on different nodes of the database</p>
          <p>Secondary indexes</p>
          <p>Provisioned capacity: number of reads and writes. Dynamodb will auto scale</p>
          <p>on-demand capacity: pay for what you use. No auto scaling.</p>
          <h3>Redshift</h3>
          <p>Large scale analytics</p>
          <p>Setup in minutes</p>
          <p>Warehouse and data lake</p>
          <ol>
            <li>Encryption</li>
            <li>Scale to petabytes</li>
            <li>Query S3</li>
            <li>Economical</li>
          </ol>
          <p>Node type</p>
          <ol>
            <li>Dense compute: fast CPUs, large RAM and SSD for fast performance</li>
            <li>Dense storage</li>
          </ol>
          <p>Same example as before.</p>
          <p>They want to have minimum effort to do the migration</p>
          <p>They want to leverage managed services</p>
          <p>Improve availability</p>
          <p>They have decided to use RDS. Using SQL server. Structured data. No servers to manage. High availability</p>
          <p>New application.</p>
          <p>DynamoDB. Flexible data structure(NoSQL). Trigger action(Lambda integration). Flexible cost structure(On-demand pricing). Global tables.</p>
          <h2 id="Part5">
            <a href="#title" class="headerlink" title="Part 5">Part Five: Evaluating Network Performance Options</a>
          </h2>
          <h3>Region and AZ</h3>
          <p>Regions are geographical area. One region may have multiple AZs that are also isolated to each other.</p>
          <p>While the AZs are isolated geographically, they are connected by AWS that allows data to be transferred between each zones.</p>
          <h4>Local Zones</h4>
          <p>Some users still think the regions provided by AWS have high latency. They can choose to use local zones. They are built in large cities and connected to near by regions with low latency, high throughput connectivity. Local zones don't have all the services provided by AWS as normal AZs.</p>
          <p>Why do we choose one region over another?</p>
          <ol>
            <li>Laws and Regulations: e.g. Some governments required that any data of their citizens remain in their countries</li>
            <li>User location: put application closer to your end users.</li>
            <li>Data location</li>
            <li>Cost</li>
          </ol>
          <h3>CloudFront</h3>
          <p>Global network: CloudFront is outside of AWS regions, that deliver our applications to end users</p>
          <p>Content delivery: Similar to CDN</p>
          <ol>
            <li>Static content: static content is cached to the place closer to end users to reduce latency</li>
            <li>Dynamic content: AWS also supported Dynamic content (intelligent caching)</li>
            <li>Intelligent: you can setup geo-restrictions to not allow edge content to deliver content to certain geo-locations</li>
            <li>Programmable: Lambda at edge: create serverless functions at edge locations. Put compute power closer to your end users.</li>
          </ol>
          <h3>Route53</h3>
          <p>DNS solution for AWS: translate a user-friendly URL to the IP address</p>
          <p>Private DNS: Route53 supports private DNS, you can setup friendly names for your internal services</p>
          <h4>Traffic flow</h4>
          <p>If you deploy your solution to multiple regions, you can config so that your users only send requests to their regions.</p>
          <ol>
            <li>Latency routing: Traffic flow will determine the region that will be serving the content with the least latency</li>
            <li>Geographic routing: route users to the cloest region.</li>
            <li>Health based routing: not route users to a region that with unhealthy status.</li>
            <li>Round robin routing: route user to the next region available. Route traffic evenly to all regions.</li>
          </ol>
          <h3>Direct Connect</h3>
          <p>Instead of going through public internet, AWS will create a dedicated line for users to connect from AWS to your data center. It is encrypted and you can config the speed.</p>
          <h3>VPC endpoints</h3>
          <p>Normally, if your VPC wants to connect to other AWS services, it can only go through public internet, but with VPC endpoints, it can connect to other AWS services directly through the private internet AWS network</p>
          <h3>EC2 instance types</h3>
          <p>some EC2 instance types have better internet performance than others. Pay attention to it before you launch the EC2 instance. Choose the type that suitable for your applications.</p>
          <h3>Apply our knowledge</h3>
          <p>They want their application to be deployed in a single region but to multiple AZs. They use AWS ECS(elastic container service) to manage their application. And use AWS Fargate to manage their containers. They also choose to use Multi-AZ RDS for their DB. They also want their Data to be stored in S3. So they want a VPC endpoint for S3 to reduce latency. So when they want to access data in S3. they don't need to go through public internet.</p>
          <p>They also have a new application that they want to have a friendly domain name. Reduced latency and managed cost. So they have decided to use Route53. because the application is hosted on S3 buckets. They need to register domain names for each S3 bucket. And configure Route 53 to route traffic to right S3 bucket using their domain names. They also want to have a global portal that has links to each deployed regions.</p>
          <h2 id="Part6">
            <a href="#title" class="headerlink" title="Part 6">Part Six: Preparing to Improve Your Architecture</a>
          </h2>
          <h3>CI/CD pipeline (Continuous Integration/ Continuous Deployment)</h3>
          <p>We need to have repeatable builds, repeatable infrastructrue and Controlled tests</p>
          <img src="1.png">
          <h3>CloudFormation</h3>
          <ol>
            <li>Infrastructure template(JSON or YAML)</li>
            <li>Automate creation</li>
            <li>Ensure consistency</li>
          </ol>
          <h3>CloudFormation templates</h3>
          <img src="2.png">
          <img src="3.png">
          <img src="4.png">
          <ol>
            <li>Format version</li>
            <li>Description</li>
            <li>Parameters</li>
            <li>Resources</li>
            <li>Output</li>
          </ol>
          <h2 id="Part7">
            <a href="#title" class="headerlink" title="Part 7">Part Seven: Monitoring Your Architecture</a>
          </h2>
          <h3>Monitor</h3>
          <ol>
            <li>Resources</li>
            <li>Application</li>
            <li>Operations</li>
          </ol>
          <h3>Respond</h3>
          <ol>
            <li>Ignore</li>
            <li>Manually</li>
            <li>Automate</li>
            <li>Modify</li>
          </ol>
          <h3>CloudWatch</h3>
          <p>Metrics</p>
          <ol>
            <li>Application</li>
            <li>Infrastructure</li>
            <li>AWS or on-premises</li>
          </ol>
          <p>Actions: Autoscaling.</p>
          <p>Actions: Messages</p>
          <p>Actions: Lambda functions can be triggered from CloudWatch</p>
          <p>Analytics: CloudWatch can store months of histoical data for you to analyse</p>
          <h3>Create a log to delete S3 object</h3>
          <ol>
            <li>Create CloudTrail Trail</li>
            <li>Create Lambda function</li>
            <li>Create CloudWatch Rule</li>
          </ol>
          <p>Create a CloudTrail Trail</p>
          <img src="5.png">
          <p>Create a Lambda function</p>
          <img src="6.png">
          <p>Create CloudWatch Rule</p>
          <img src="7.png">
          <h2 id="Part8">
            <a href="#title" class="headerlink" title="Part 8">Part Eight: Understanding the Trade-offs</a>
          </h2>
          <ol>
            <li>Time</li>
            <li>Cost</li>
            <li>Memory</li>
            <li>Efficiency</li>
            <li>Complexity</li>
          </ol>
          <h3>Possible Trade-offs</h3>
          <ol>
            <li>Queuing</li>
            <li>Partitioning</li>
            <li>Caching</li>
            <li>Compression</li>
          </ol>
          <h3>Queuing</h3>
          <p>AWS SQS (simple queuing service)</p>
          <ol>
            <li>Decouple (producer, consumer)</li>
            <li>Scale independently (add producer or delete consumer)</li>
            <li>Acceptable delay</li>
            <li>Time vs Efficiency</li>
          </ol>
          <h3>Data Paritioning</h3>
          <p>For example: RDBMS doesn't have partition. so we need to consider what data goes into which instance of database, that increase complexity. Whereas many NoSQL DB already has partition. In DynamoDB, we have partition key for each table. The data that has the same partition key will go into the same node. So when choose a partition key, choose a key that roughly evenly distributed across the data.</p>
          <ol>
            <li>Complexity / consistency vs Time</li>
            <li>RDBMS vs NoSQL</li>
            <li>Distribution</li>
            <li>Maintenance</li>
          </ol>
          <h3>Caching</h3>
          <p>Cache: heavliy used data will be stored in memory.</p>
          <p>Read Replics: if you have a read replica of your DB, users can go into read replica if they only read. Reduce the traffic of your primary server.</p>
          <p>CDN: take data and store data closer to users place.</p>
          <p>Memory/ consistency vs Time</p>
          <h3>Compression</h3>
          <p></p>
          <ol>
            <li>Code assets: reduce the size of source code to reduce the time to load the application</li>
            <li>Files: same. redurce the size of file will reduce the transfer time</li>
            <li>Time vs memory</li>
          </ol>
        </div>
      </article>
    </div>
  </section>
  <footer>
    <div class="paginator">
      <a href="/2020/10/15/AWS_Solutions_Architect_Associate" class="next">下一篇</a>
    </div>
  </footer>
    <div id="disqus_thread"></div>
    <script>
  var disqus_shortname = 'hellcy';
  
  var disqus_url = 'https://hellcy.github.io/2021/01/26/AWS_SAA_Architecting_For_Performance_Efficiency';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <script id="dsq-count-scr" src="//https-hellcy-github-io.disqus.com/count.js" async></script>
    <script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </body>
</html>