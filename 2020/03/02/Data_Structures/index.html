<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="X-UA-Compatible" content="IE=edge">
  <title>Data Structures</title>
  <meta name="description" content="Data Structures - hellcy">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="short icon" href="/sitelogo.jpg">
  <link rel="stylesheet" href="/css/apollo.css">
</head>
<body>
  <header>
    <a href="/" class="logo-link"><img src="/sitelogo.jpg"></a>
    <ul class="nav nav-list">
      <li class="nav-list-item">
        <a href="/" target="_self" class="nav-list-link">Blog</a>
      </li>
      <li class="nav-list-item">
        <a href="https://github.com/hellcy" target="_blank" class="nav-list-link">Github</a>
      </li>
    </ul>
  </header>
  <section class="container">
    <div class="post">
      <article class="post-block">
        <h1 class="post-title">Data Structures</h1>
        <div class="post-time">Mar 20, 2020</div>
        <div class="post-content">
          <h2 id="u6587_u7AE0_u7ED3_u6784">
            <a href="#u6587_u7AE0_u7ED3_u6784" class="headerlink" title="Binary Search"></a>Binary Search
          </h2> 
          <p>Use O(1) to make a T(n) problem T(n/2). So the total time complexity would be O(logn).</p>
          <p>Ignore half of the problems in O(1) time.</p>
          <p>First Bad Version</p>
          <p>Search in a Big Sorted Array. Double the search number every time, then serach from n to 2n</p>
          <p>Find Minimum in Rotated Sorted Array. Divide the array into a normal sorted array and a smaller rotated sorted array.</p>
          <p>Search in a 2D matrix. Perform Binary Search 2 times. First find the row, then perform binary search on that row.</p>
          <p>Search for a Range. Find the target number then perform binary search on its left and right.</p>
          <p>Maximum Number in Mountain Sequence. Check mid number to see if it is incresing or decresing, we can return any mountain value.</p>
          <h2 id="u6587_u7AE0_u7ED3_u6784">
            <a href="#u6587_u7AE0_u7ED3_u6784" class="headerlink" title="Bianry Tree and Divide & Conquer"></a>Bianry Tree and Divide & Conquer
          </h2> 
          <p>There are 3 ways to traverse a binary tree. Pre order, In order and post order</p>
          <p>You need to know both resursive version and iterative version.</p>
          <p>DFS includes pre order, in order, post order, divide & conquer</p>
          <p>Bianry tree has height from O(logn) to O(n), traverse a binary tree takes O(n) time.</p>
          <p>In order traverse a binary search tree is an increasing order traverse.</p>
          <p>Maximum depth of Binary tree. Resursive: Divide and conquer/ traverse</p>
          <p>Subtree with Maximum Average</p>
          <p>Lowest Common Ancestor: Divide & Conquer, check leftsubtree and rightsubtree. See if they return A or B or null</p>
          <p>Validate Binary Search Tree. Bottom up, return max and min return to the parent node.</p>
          <p>Convert Binary Search Tree to Doubly Linked List. Inorder traverse it into a list and convert it.</p>
          <p>Flattern Binary Tree to Linked List. node.right = head of left subtree, tail of left subtree = head of right subtree.</p>
          <p>Insert and delete a node from a Binary Search Tree</p>
          <h2 id="u6587_u7AE0_u7ED3_u6784">
            <a href="#u6587_u7AE0_u7ED3_u6784" class="headerlink" title="BFS"></a>BFS
          </h2> 
          <p>1. make a list and put all start nodes into the list</p>
          <p>2. traverse the list to get new nodes for the next level</p>
          <p>3. use Queue for BFS</p>
          <p>Graph BFS</p>
          <p>Social Network</p>
          <p>六度理论 你和世界上任何一个人之间最多间隔6个人 Linkedin BFS看第几层有相同好友</p>
          <p>树和图的区别，树是单向的，图可以是双向的（或者单项）</p>
          <p>在遍历图中，会有环，可以用HashSet检查是否曾经访问过某个节点</p>
          <p>树的特性，树中如果有N个点，就会有N-1条边。树中的所有点连通。用Queue和Set访问并保存所有Graph中的点</p>
          <p>构造Graph， 可以用 Map&#60;Integer, Set&#60;Integer&#62;&#62; Graph其实就是保存着（每个点和与他相邻的点的Set）的Map</p>
          <p>BFS on a 2D-array</p>
          <p>Number of islands</p>
          <p>Wall and Gates</p>
          <p>什么时候使用BFS？</p>
          <p>1. Tree的层次遍历</p>
          <p>2. 2D-array中求连通性，灌水</p>
          <p>3. 拓扑排序</p>
          <p>4. 图的最短路径</p>
          <h2 id="u6587_u7AE0_u7ED3_u6784">
            <a href="#u6587_u7AE0_u7ED3_u6784" class="headerlink" title="DFS"></a>DFS
          </h2> 
          <p>Recursion</p>
          <p>Combination</p>
          <p>Permutation</p>
          <p>Graph</p>
          <p>Non-Recursion</p>
          <p>什么时候使用DFS？</p>
          <p>1. 找所有方案，排列，组合</p>
          <p>2. 找最优方案（最短，最长）（大部分是动态规划，也有可能是DFS）</p>
          <p>Questions</p>
          <p>1. Combination sum</p>
          <p>2. Palindrome Partitioning 所有的切割问题都是组合问题</p>
          <p>切割abc字符串，有两个切割位 a1b2c， 可以切ab之间也可以切bc之间，把数字12放入代表切割位，所以切割的方式有</p>
          <p>a b c [1,2]</p>
          <p>a bc [1]</p>
          <p>ab c [2]</p>
          <p>abc []</p>
          <p>以上可以看出四种切割方式可以用数字表示</p>
          <p>所以n个字母的切割问题可以看作是n - 1个数字的组合问题</p>
          <p>Backtracking</p>
          <p>Permutation的去重与Combination相似，可以先定义一个boolean数组存放visited信息</p>
          <p>N皇后</p>
          <p>每一行和每一列都是1...n的一种排列</p>
          <p>如何判断皇后在同一斜线上： 横坐标与纵坐标之差相等，或者横坐标与纵坐标之和相等</p>
          <p>Word Ladder: BFS, 把ListWord转换成graph的形式，对于每个word，先找到所有可能的变换，总共有单词长度*26种，然后这些变换中存在于Wordlist中的就是他的neighbor，就可以变成标准的BFS问题</p>
          <p>Word Ladder 2：Backtracking + BFS， 先从End往Begin做BFS找到每个单词距离End的长度，保证Backtrack时不会遍历更远的单词。再从Begin往End做backtracking</p>
          <h2 id="u6587_u7AE0_u7ED3_u6784">
            <a href="#u6587_u7AE0_u7ED3_u6784" class="headerlink" title="Linked List and Array"></a>Linked List and Array
          </h2> 
          <p>Reverse linked list</p>
          <p>Reverse linked list in k group</p>
          <p>Use dummy node to save the list head</p>
          <p>画图去理解linked list的变化</p>
          <p>dummy node practices</p>
          <ol>
            <li>partition-list</li>
            <li>merge two sorted list</li>
            <li>reverse linked list 2</li>
            <li>swap two nodes in linked list</li>
            <li>reorder list</li>
            <li>rotate list</li>
          </ol>
          <p>Copy list with random pointer -> similar to clone graph</p>
          <p>Linked List Cycle 1 and 2 -> Floyd's Tortoise and Hare</p>
          <p>Sort List -> how many sort algorithm has time complexity O(nlogn)?</p>
          <ol>
            <li>Quick Sort, with O(1) Space Complexity</li>
            <li>Merge Sort, with O(n) space</li>
            <li>Heap Sort</li>
          </ol>
          <p>Merge two sorted array</p>
          <p>Merge small array into big array</p>
          <p>intersection of two arrays</p>
          <p>Median of two sorted arrays -> find the (m + n) / 2th number, use O(logn)</p>
          <p>Median</p>
          <p>Kth largest element</p>
          <p>Merge Sort practice</p>
          <p>Quick Sort practice</p>
          <p>Same integers will not remain their relative order in the old list after using quick sort. Merge sort will keep the relative order of same integers</p>
          <p>Merge sort will first split the array into two subarray until there is only one number left in the array, then sort, then merge the two sorted array back to one array. From small array to big array</p>
          <p>Qucik sort will first pick a pivot value, sort the entire array based on the pivot value. Then sort the two small array. From big array two small array</p>
          <p>Note in Quick Sort, when we find a value equals to the pivot value, we don't swap it, leave it as where it is. We need to split these values as even as possible.</p>
          <p>Quick sort while loop condition: while (left <= right). Don't forget the equal sign</p>
          <h2 id="u6587_u7AE0_u7ED3_u6784">
            <a href="#u6587_u7AE0_u7ED3_u6784" class="headerlink" title="Subarray"></a>Subarray
          </h2> 
          <p>PrefixSum, HashMap to store prefixsum, then linear scan, So O(n) time and space</p>
          <p>Maximum subarray</p>
          <p>Minimum subarray</p>
          <p>subarray sum equals k</p>
          <p>number of subarray equals k</p>
          <h2 id="u6587_u7AE0_u7ED3_u6784">
            <a href="#u6587_u7AE0_u7ED3_u6784" class="headerlink" title="Two pointers"></a>Two pointers
          </h2> 
          <p>O(n) time complexity</p>
          <p>同向双指针</p>
          <p>Move zeros</p>
          <p>Remove duplicate number in array</p>
          <p>Remove duplicate numbers in sorted array -> tortise and hare cycle detection</p>
          <p>相向双指针</p>
          <p>valid palindrome</p>
          <p>rotate string -> three step reverse, when reverse a string, one start from begin and another start from end</p>
          <p>recover rotated sorted array -> similar to above, find the rotate point, three step reverse.</p>
          <p>Two Sum 1-7</p>
          <p>Two Sum 1 -> 最普通的Two Sum， 可以使用HashMap，或者先排序在使用相向双指针，这样可以不是用额外空间，但是时间复杂度是O(nlogn)</p>
          <p>Two Sum 2 - Data Structure Design -> HashMap</p>
          <p>Two Sum 3 - Array is sorted -> 相向双指针</p>
          <p>Two sum 7 - unique pairs -> 找到所有符合的数对,相向双指针，当找到一对时，left++,right--,并继续。如果遇到重复比如1,1,3,4,4,每次我们移动时，移动到与之前的数不一样的数为止。注意此方法要求数组是有序的。</p>
          <p>3Sum -> 使用Two sum的结果，对于array中的每一个不等的数，检查是否有一对数的和等于它的相反数。可以使用HashMap或者two pointers，记住two pointers必须先排序数组。Two pointers的速度远快于HashMap</p>
          <p>Valid Triangle Number -> 检查有多少组三个数可以组成合法的三角形的三条边。注意我们只需要检查最小的两个数的和大于第三个数即可. 从最大的数开始loop，使用Two pointers，对于每一个符合的left and right， 所有大于left的数都是符合的，所以每当我们找到一组合法的left and right，count += （right - left）. 详情查看leetcode 611</p>
          <p>对于求2个变量如何组合的问题，可以循环其中一个变量，然后研究另外一个变量如何变化</p>
          <p>对于求3个变量如何组合的问题，可以循环其中一个变量，然后研究另外2个变量如何变化</p>
          <p>对于求4个变量如何组合的问题，可以循环其中两个变量，然后研究另外2个变量如何变化</p>
          <p>Two Sum less than k</p>
          <p>Two Sum greater than k -> same as triangle count</p>
          <p>Two Sum closest to target -> two pointers start from begin and end, keep updating diff</p>
          <p>3 Sum closest to target -> similar to above, loop one value and use two sum as a template</p>
          <p>4 Sum</p>
          <p>Two Sum - difference equals to target -> 同向双指针。两数之差等于target，先排序，两个pointers都在开始，如果他们的差大于target，小数往后移，如果他们的差小于target，大数往后移 O(n) time complexity</p>
          <p>Partition array</p>
          <p>move elements < k to the left and elements >= k to the right, this is a smaller step in quick sort</p>
          <p>Parition array while loop condition: while (left < right). No equal sign</p>
          <p>Letters by case</p>
          <p>Partition array by parity</p>
          <p>Interleaving positive and negative numbers -> first count positive and negative numbers, then decide starts from positive or negative, then use two pointers in the same direction.</p>
          <p>Sort Colors</p>
          <p>1. sort 3 colors in group, we can use partition array two times, first time split one color, next split the rest two colors.</p>
          <p>2. We could also count the number of each color and modify the array to match the occurance of colors</p>
          <p>3. three pointers</p>
          <ol>
            <li>i pointer only moves when find ones and zeros, if it finds two, it will swap it with right. Throw two to the right</li>
            <li>so left pointer will never find two.</li>
            <li>so when i pointer finds zero, after swap it with left pointer, throw zero to the left, left pointer will only throw one back, so they can both move to right by 1</li>
          </ol>
          <p>Sort Colors 2 (rainbow sort) -> 使用多次Partition， 每次将一般的颜色分到array的左右，比如只有四种颜色，一次partition将1，2分到左边，3，4分到右边。花费O（n）的时间将T(k)的问题变成T(k/2)的问题。总共的时间复杂度为O(nlogk)</p>
          <p>这个解法有点像Quick Sort。注意Quick sort and Rainbow sort的while loop条件均为 while(left < right)。可以不用要等号</p>
          <p>其他比较高频的排序方法：</p>
          <p>Pancake Sort</p>
          <p>Sleep Sort</p>
          <p>Spaghetti Sort</p>
          <p>Bogo Sort</p>
          <h2 id="u6587_u7AE0_u7ED3_u6784">
            <a href="#u6587_u7AE0_u7ED3_u6784" class="headerlink" title="3 Step Reverse"></a>3 Step Reverse
          </h2> 
          <p>Three step reverse</p>
          <p>Recover rotated sorted array -> First use 3 step reverse then two pointer reverse.</p>
          <p>3 step reverse</p>
          <p>First find the rotate point</p>
          <p>Reverse the first part(before rotate point) of the String/array</p>
          <p>Reverse the second part(after rotate point) of the String/array</p>
          <p>Reverse the entire String/array</p>
          <h2 id="u6587_u7AE0_u7ED3_u6784">
            <a href="#u6587_u7AE0_u7ED3_u6784" class="headerlink" title="Quick Select"></a>Quick Select
          </h2>
          <p>Quick Select 快速选择算法</p>
          <p>思想类似于快速排序,利用O(n)的时间找到前right个大数，再看k与right的关系决定下一步recursion的范围</p>
          <p>O(n) + O(n/2) + O(n/4) +... = O(n) time</p>
          <p>kth largest element</p>
          <p>Median</p>
          <p>kth smallest element</p>
          <p>Median of two sorted arrays</p>
          <h2 id="u6587_u7AE0_u7ED3_u6784">
            <a href="#u6587_u7AE0_u7ED3_u6784" class="headerlink" title="Hash & Heap"></a>Hash & Heap
          </h2>
          <p>了解他们的原理和应用</p>
          <p>TreeMap</p>
          <p>队列Queue</p>
          <p>支持操作O(1) push O(1) pop O(1) top,多做跟BFS有关的题目</p>
          <p>栈Stack</p>
          <p>支持操作O(1) push O(1) pop O(1) top,非递归实现DFS的主要数据结构</p>
          <p>哈希表Hash</p>
          <p>支持操作O(1) insert O(1) find O(1) delete, Hash table / Hash map / Hash set的区别是什么</p>
          <p>Hash Set只存key不存value</p>
          <p>Hash map存key和value</p>
          <p>Hash table，多线程安全，当多个线程同时访问一个Hash table时，它可以保证数据安全，Hash Map无法做到</p>
          <p>Hash function -> 对于任意的Key，得到一个固定且无规律的介于0到capacity - 1的整数</p>
          <p>数据结构分为连续性和离散型，array为连续性，List为离散型</p>
          <p>一些著名的Hash算法：MD5， SHA-1， SHA-2，主要用于加密</p>
          <p>用于算法中的Hash function很想进制转换</p>
          <pre>
            int hashfun(String key) {
              int sum = 0;
              for (int i = 0; i < key.length(); ++i) {
                sum = sum * 31 + (int)(key.charAt(i));
                sum = sum % HASH_TABLE_SIZE;
              }
              return sum;
            }
          </pre>
          <p>Magic number - 31</p>
          <p>通过经验得出31的冲突更少（Collision）</p>
          <p>Magic number取质数更好，如果数太大影响效率，数太小冲突太多</p>
          <p>Closed Hashing - line sweep</p>
          <p>当哈希表发生冲突时，把新的数据插入到下一个空的位置</p>
          <p>寻找，不断的找下一个位置直到找到value或者找到空位为止</p>
          <p>删除，把值删除后用一个deleted标记出来，这个位置并不为空</p>
          <p>缺点，当我们插入和删除的次数很多时，很多位置都会被标记为deleted，寻找的效率会变低</p>
          <p>Open Hashing</p>
          <p>每一个位置都是一个链表，当发生冲突时加到链表的开头，这样不用每次都遍历到链表末尾，寻找时搜寻整个链表</p>
          <p>Rehashing</p>
          <p>当hash table size不够用了怎么办？</p>
          <p>像ArrayList那样不断倍增</p>
          <p>怎么定义满？当实际的存储个数达到总共空间的1/10(经验值)时，我们就需要rehash</p>
          <p>回顾ArrayList的倍增：当ArrayList满时，把size扩大两倍，把前面的所有数复制到后一半新扩大的ArrayList中</p>
          <p>Hash Table的倍增：如果移动之前的数，会影响到hash function，所以我们会先扩大hash table， 再把hash table中的所有值重新放到hash function算出它在新的hash table中的位置，重新插入</p>
          <p>Rehashing很慢，所以在定义hash table的时候最好提前定义一个size，让他尽量不要rehash</p>
          <p>在存储快的和存储慢的介质之间都会存在Cache的问题，不仅在CPU和内存之间有</p>
          <p>使用链表储存数据的的插入顺序，使用哈希表判断将要插入的数据是否已经存在于链表中</p>
          <p>LinkedHashMap = DoublyLinkedList + HashMap</p>
          <p>LRU Cache -> 使用HashMap + DoublyLinkedList可以解决</p>
          <p>Heap</p>
          <p>支持操作O(logn) add O(logn) remove O(1) MIN or MAX,求最大值或最小值只可取其一</p>
          <p>ugly number 2</p>
          <p>top k largest number 2 -> 使用PriorityQueue只保存k个数</p>
          <p>merge k sorted list -> Add all list heads to a heap, poll the smallest head, add to ans, then add next node to heap.</p>
          <p>注意要会写heap的comparator</p>
          <p>Practice</p>
          <ol>
            <li>high five</li>
            <li>k closest points</li>
            <li>data stream median</li>
            <li>kth smallest number in sorted matrix</li>
          </ol>
          <h2 id="u6587_u7AE0_u7ED3_u6784">
            <a href="#u6587_u7AE0_u7ED3_u6784" class="headerlink" title="Dynamic programming"></a>Dynamic Programming
          </h2>
          <p>动态规划的分类</p>
          <p>Triangle -> 入门题</p>
          <p>注意以下代码中n为三角形的高度</p>
          <p>第一种方法 DFS Traverse, Top-down</p>
          <pre>
            void traverse(int x, int y, int sum) {
              if (x == n) {
                // found a whole path from top to bottom
                if (sum < best) {
                  best = sum;
                }
                return;
              }

              traverse(x + 1, y, sum + A[x][y]);
              traverse(x + 1, y + 1, sum + A[x][y]);
            }

            best = MAXINT;
            traverse(0, 0, 0);
          </pre>
          <p>每一个节点都分出来两条路径，相当于一个binary tree， 它的节点个数是2^n, 所以这个方法的时间复杂度是O(2^n)</p>
          <p>第二种方法 DFS Divide and Conquer, bottom-up</p>
          <pre>
            // return minimum path from (x, y) to bottom
            int divideConquer(int x, int y) {
              if (x == n) {
                return 0;
              }
              return A[x][y] + Math.min(
                divideConquer(x + 1, y),
                divideConquer(x + 1, y + 1)
              );
            }

            divideConquer(0, 0);
          </pre>
          <p>与之前一样，每一个节点都分出来两条路径，相当于一个binary tree， 它的节点个数是2^n, 所以这个方法的时间复杂度是O(2^n)</p>
          <p>DFS实际上是在枚举，把所有的方案都列出来然后看哪个更好</p>
          <p>我们做了很多重复计算，因为实际上我们只需要计算三角形所有节点（n^2个）的最短路径，DFS却计算了（2^n个）节点，很多节点我们计算了很多遍。所以我们需要把每个节点的结果保存下来，下次需要的时候就不需要重新算了</p>
          <p>第三种方法 DFS Divide and conquer + Memorization</p>
          <pre>
            // return minimum path from (x, y) to bottom
            int divideConquer(int x, int y) {
              // row index from 0 to n - 1
              if (x == n) return 0;

              // if we already got the minimum path from (x, y) to bottom, just return it
              if (hash[x][y] != Integer.MAX_VALUE) return hash[x][y]

              // set before return
              hash[x][y] = A[x][y] + Math.min(divideConquer(x + 1, y), divideConquer(x + 1, y + 1));

              return hash[x][y]
            }

            initialize: hash[*][*] = Integer.MAX_VALUE;
            answer: divideConquer(0, 0);
          </pre>
          <p>在每次计算节点最小值之前，先看看之前有没有算过这个节点的结果，如果有直接从数组中拿到结果并返回，没有算过我们再递归, O(n^2) time</p>
          <p>记忆化搜索的本质：动态规划，省去了重复计算</p>
          <p>多重循环 vs 记忆化搜索</p>
          <p>第四种方法 多重循环，自底向上</p>
          <pre>
            int[][] dp = new int[row][row]; // dp[i][j] 表示从i， j出发走到最后一层的最小路径长度

            // 初始化，终点先有值,最后一层
            for (int i = 0; i < n; ++i) {
              dp[n - 1][i] = triangle[n - 1][i];
            }

            // 循环递推求解
            for (int i = n - 2; i >= 0; --i) {
              for (int j = 0; j <= i; ++j) {
                dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j +1]) + A[i][j]
              }
            }

            // 求结果： 起点
            return dp[0][0];
          }
          </pre>
          <p>O(n^2) time,没有递归</p>
          <p>第五种方法 多重循环，自顶向下</p>
          <pre>
            int[][] dp = new int[row][row];

            // 初始化，起点
            dp[0][0] = triangle[0][0];

            // 初始化三角形的左边和右边
            for (int i = 1; i < row; ++i) {
              dp[i][0] = dp[i - 1][0] + triangle[i][0]; // 左边
              dp[i][i] = dp[i - 1][i - 1] + triangle[i][i]; // 右边
            }

            // top down
            for (int i = 1; i < row; ++i) {
              for (int j = 1; j < i; ++j) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][j - 1]) + triangle[i][j];
              }
            }

            Math.min(dp[row - 1][0], dp[row - 1][1], dp[row - 1][2]...);
          </pre>
          <p>这个方法中dp[x][y]表示从上到下到这个点的最短路径</p>
          <p>O(n^2) time,没有递归,但是这个方法我们必须提前算出三角形的左边和右边，因为对于三角形的每一个结点dp[x][y]，我们在计算到他的最短路径的时候，我们需要用到它前一层的两个点dp[x-1][y]和dp[x-1][y-1].但是对于每一层的最左边和最右边的点，我们再上一层找不到再靠左边或者右边的点，所以为了避免越界，我们必须提前算出两条边的所有点。</p>
          <p>什么情况下使用动态规划？</p>
          <p>满足下满三个条件之一：</p>
          <ol>
            <li>求最大值最小值</li>
            <li>判断是否可行</li>
            <li>统计方案个数</li>
          </ol>
          <p>上面这三个情况极有可能需要使用动态规划</p>
          <p>什么情况下不使用动态规划？</p>
          <ol>
            <li>求出所有具体的方案，而不是方案的个数 -> palindrome-paritioning</li>
            <li>输入数据是一个集合而不是序列,意思是如果我们可以将数据调换位置，则很有可能不使用动态规划，动态规划需要有方向性 -> longest-consecutive-sequence</li>
            <li>暴力算法的复杂度已经是多项式级别。 动态规划擅长优化指数级别的复杂度（2^n, n!）到多项式级别的复杂度(n^2, n^3)</li>
          </ol>
          <p>动态规划四要素</p>
          <ol>
            <li>状态，储存小规模问题的结果</li>
            <li>方程，状态之间怎么联系</li>
            <li>初始化，最极限的小状态是什么，起点</li>
            <li>答案，最终的状态是什么，终点</li>
          </ol>
          <p>动态规划的类型，按照状态分类</p>
          <ol>
            <li>坐标型 triangle 10%</li>
            <li>接龙型 20%</li>
            <li>划分型</li>
            <li>匹配型</li>
            <li>背包型</li>
            <li>区间型 longest palindrome</li>
            <li>树图型 tree matrix</li>
            <li>博弈型 判断是否可行</li>
          </ol>
          <p>坐标型动态规划</p>
          <p>状态</p>
          <p>f[x]:表示我从起点走到坐标x。。。</p>
          <p>f[x][y]:表示我从起点走到坐标x, y...</p>
          <p>方程：研究走到x， y这个点之前的一步</p>
          <p>practice: minimum path sum</p>
          <p>动态规划不应该存在循环依赖，从一个状态不会回到之前的一个状态</p>
          <p>当我们初始化一个二维数组的动态规划时，需要初始化第0行和第0列</p>
          <p>Unique path</p>
          <p>Unique path 2</p>
          <p>Climbing Stairs</p>
          <p>Jump game</p>
          <p>Jump game 2</p>
          <p>接龙型动态规划</p>
          <p>告诉你一个规则然后求最长的状态可以是多少，比如数组中求最大递增子序列</p>
          <p>Longest increasing subsequence</p>
          <p>Russian Doll Envelopes</p>
          <p>Largest Divisible Subset</p>
          <p>Frog jump</p>
          <p>总结</p>
          <p>动态规划的实质是记忆化搜索，避免重复计算中间结果</p>
          <p>动态规划四要素：初始化，方程，起点，终点</p>
          <p>什么时候使用动态规划:最优，可行，方案数（而非具体方案）</p>
          <p>什么时候不使用：求具体方案，输入数据为集合而非序列（可调整顺序），暴力算法时间复杂度已经是O(n^2, n^3)</p>
        </div>
      </article>
    </div>
  </section>
  <footer>
    <div class="paginator">
      <a href="/2019/10/24/Single_sign_on/" class="next">下一篇</a>
    </div>
  </footer>
    <div id="disqus_thread"></div>
    <script>
  var disqus_shortname = 'hellcy';
  
  var disqus_url = 'https://hellcy.github.io/2020/03/02/Data_Structures/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <script id="dsq-count-scr" src="//https-hellcy-github-io.disqus.com/count.js" async></script>
    <script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </body>
</html>